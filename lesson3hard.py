# Задание - 1
# Давайте опишем пару сущностей player и enemy через словарь,
# который будет иметь ключи и значения:
# name - строка полученная от пользователя,
# health - 100,
# damage - 50.
# Поэксперементируйте с значениями урона и жизней по желанию.
# Теперь надо создать функцию attack(person1, person2), аргументы можете указать свои,
# функция в качестве аргумента будет принимать атакующего и атакуемого,
# функция должна получить параметр damage атакующего и отнять это количество
# health от атакуемого. Функция должна сама работать с словарями и изменять их значения.
# Задание - 2
# Давайте усложним предыдущее задание, измените сущности, добавив новый параметр - armor = 1.2
# Теперь надо добавить функцию, которая будет вычислять и возвращать полученный урон по формуле damage / armor
# Следовательно у вас должно быть 2 функции, одна наносит урон, вторая вычисляет урон по отношению к броне.
# Сохраните эти сущности, полностью, каждую в свой файл,
# в качестве названия для файла использовать name, расширение .txt
# Напишите функцию, которая будет считывать файл игрока и его врага, получать оттуда данные, и записывать их в словари,
# после чего происходит запуск игровой сессии, где сущностям поочередно наносится урон,
# пока у одного из них health не станет меньше или равен 0.
# После чего на экран должно быть выведено имя победителя, и количество оставшихся единиц здоровья.


# Комментарий разработчика: вместо armor использую shield - каждый раз нужно ударить сильнее щита, чтобы зацепить здоровье персонажа

import random

# функция считывания данных персонажа из файла
def read_person():
	name = input("Введите имя персонажа, которое хотите считать: ")
	person = {}
	
	try: # если файл персонажа найден, то создаем персонажа с характеристиками из файла
		with open(name + '.txt') as file_obj:
			for string in file_obj.readlines():
				new_string = string.split(': ')
				if new_string[1].strip().isdigit(): # цифры должны быть цифрами
					person[new_string[0]] = int(new_string[1].rstrip())
				else:
					person[new_string[0]] = new_string[1].rstrip()
			return person
	except FileNotFoundError: # если файл не найден, то создадим персонажа
		print(f"Файл {name}.txt не найден.")
		return create_person()

# функция создания персонажа и указания его здоровья
def create_person():
	name = input(f"Создадим персонажа. Введите имя персонажа: ")

	print("\nСправка: максимальное здоровье вместе с силой составляет 150 единиц. Если вы укажете 100 единиц здоровья, значит сила будет 50 единиц. Балансируйте. На этом шаге вы закладываете стратегически важные показатели персонажа для победы.")
	
	health = int(input(f"Для персонажа {name.title()} введите значение здоровья от 50 до 100 единиц: "))
	while health < 50 or health > 100:
		health = int(input(f"Значение здоровья должно быть от 50 до 100 единиц. Попробуйте вновь ввести значение здоровья для персонажа {name.title()}: "))

	damage = 150 - health
	print(f"\nВ итоге, характеристики персонажа {name.title()}: {health} единиц здоровья, {damage} единиц силы и 25 единиц защиты.\n")

	person = {'name':name.title(), 'health': health, 'damage': damage, 'shield': 25}

	# созданного персонажа сохраняем в файл имя.txt
	with open(name + '.txt', 'w') as file_obj:
		for k,v in person.items():
			file_obj.write(str(f"{k}: {v}\n"))
			
	return person

#функция имитации боя между персонажами
def fight(soldier1, soldier2):
	while soldier1['health'] > 0 and soldier2['health'] > 0:
		strike() # деремся до тех пор, пока у обоих персонажей есть жизни
	else:
		death()	# иначе определяем кто первый погиб	

# функция имитации удара персонажа
def strike():
	# каждый раз будем определять очередь удара персонажа, при этом персонаж может сделать серию ударов
	order = random.randint(1,2)
	if order == 1: # первым бьет первый персонаж
		# сгенерируем силу удара
		strike1 = random.randint(1, soldier1['damage'])
		strike2 = random.randint(1, int(soldier2['damage']/2)) # ответный удар должен быть слабее
		
		print(f"Персонаж {soldier1['name']} ♥{soldier1['health']} ударяет с силой {strike1}, а персонаж {soldier2['name']} ♥{soldier2['health']} отвечает ударом {strike2}.")
		# мы будем отнимать здоровье только когда удар сильнее щита
		if strike1 > soldier2['shield']:
			soldier2['health'] -= strike1 - 25 # щит поглощает 25 единиц удара, остальное отнимает жизнь
		if strike2 > soldier1['shield']:
			soldier1['health'] -= strike2 - 25

	else: # иначе бой начинается со второго персонажа
		# сгенерируем силу удара
		strike2 = random.randint(1, soldier2['damage'])
		strike1 = random.randint(1, int(soldier1['damage']/2)) # ответный удар должен быть слабее
		
		print(f"Персонаж {soldier2['name']} ♥{soldier2['health']} ударяет с силой {strike2}, а персонаж {soldier1['name'] } ♥{soldier1['health']} отвечает ударом {strike1}.")
		# мы будем отнимать здоровье только когда удар сильнее щита
		if strike2 > soldier1['shield']:
			soldier1['health'] -= strike2 - 25 # щит поглощает 25 единиц удара, остальное отнимает жизнь
		if strike1 > soldier2['shield']:
			soldier2['health'] -= strike1 - 25

# функция изменения статуса жизни персонажа и подведение итогов
def death():
	if soldier1['health'] <= 0:
		soldier1['status'] = 'погиб'
		soldier2['status'] = 'победил'
	else:
		soldier1['status'] = 'победил'
		soldier2['status'] = 'погиб'
	
	print(f"\nБой длился не на жизнь, а на смерть! Персонаж {soldier1['name']} {soldier1['status']}, а персонаж {soldier2['name']} {soldier2['status']}!")
	print(f"У персонажа {soldier1['name']} осталось ♥{soldier1['health']} единиц здоровья, а у {soldier2['name']} осталось ♥{soldier2['health']} единиц здоровья.")
	print("Конец игры.")


print("Добро пожаловать в игру Mortal Kombat на Python (текстовая версия)!\n".upper())

soldier1 = read_person()
soldier2 = read_person()

fight(soldier1, soldier2)
